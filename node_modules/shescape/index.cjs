'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var os = require('os');
var fs = require('fs');
var which = require('which');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var which__default = /*#__PURE__*/_interopDefaultLegacy(which);

/**
 * @overview Contains constants that may be used in multiple modules.
 * @license MPL-2.0
 * @author Eric Cornelissen <ericornelissen@gmail.com>
 */

/**
 * @constant {string} regexpPowerShell A {@link RegExp} to detect if the shell
 * to escape an argument for is "PowerShell".
 * @example regexpPowerShell.test("cmd.exe");  // -> false
 */
const regexpPowerShell = /powershell.exe$/;

/**
 * @constant {string} shellRequiredError The error message for when the shell
 * argument is missing.
 * @example throw new TypeError(shellRequiredError);
 */
const shellRequiredError =
  "Shescape requires a shell to be specified in order to escape arguments";

/**
 * @constant {string} typeError The error message for incorrect parameter types.
 */
const typeError =
  "Shescape requires strings or values that can be converted into a string using .toString()";

/**
 * @constant {string} win32 The string identifying Windows systems.
 */
const win32 = "win32";

/**
 * @overview Contains functionality related to working with executables.
 * @license MPL-2.0
 * @author Eric Cornelissen <ericornelissen@gmail.com>
 */

/**
 * Resolve the location of an executable given an arbitrary valid string
 * representation of that executable.
 *
 * To obtain the location of the executable this function (if necessary):
 * - Expands the provided string to a absolute path.
 * - Follows symbolic links.
 *
 * @param {Object} args The arguments for this function.
 * @param {string} args.executable A string representation of the executable.
 * @param {Object} deps The dependencies for this function.
 * @param {Function} deps.exists A function to check if a file exists.
 * @param {Function} deps.readlink A function to resolve (sym)links.
 * @param {Function} deps.which A function to perform a `which(1)`-like lookup.
 * @returns The full path to the binary of the executable.
 */
function resolveExecutable({ executable }, { exists, readlink, which }) {
  if (readlink === undefined || which === undefined) {
    throw new Error();
  }

  try {
    executable = which(executable);
  } catch (_) {
    // for backwards compatibility return the executable even if its location
    // cannot be obtained
    return executable;
  }

  if (!exists(executable)) {
    // for backwards compatibility return the executable even if there exists no
    // file at the specified path
    return executable;
  }

  try {
    executable = readlink(executable);
  } catch (_) {
    // An error will be thrown if the executable is not a (sym)link, this is not
    // a problem so the error is ignored
  }

  return executable;
}

/**
 * @overview Contains functionality specifically for Unix systems.
 * @license MPL-2.0
 * @author Eric Cornelissen <ericornelissen@gmail.com>
 */

/**
 * Escape a shell argument when string interpolation is *disabled* (e.g. when
 * the argument is surrounded by single quotes in bash-family shells).
 *
 * @param {string} arg The argument to escape.
 * @returns {string} The escaped argument.
 */
function escapeShellArgNoInterpolation(arg) {
  return arg.replace(/\u{0}/gu, "").replace(/'/g, `'\\''`);
}

/**
 * Escape a shell argument when string interpolation is *enabled* (e.g. when
 * the argument is surrounded by double quotes in bash-family shells).
 *
 * @param {string} arg The argument to escape.
 * @param {string} shell The shell to escape the argument for.
 * @returns {string} The escaped argument.
 */
function escapeShellArgWithInterpolation(arg, shell) {
  let result = arg
    .replace(/\u{0}/gu, "")
    .replace(/\\/g, "\\\\")
    .replace(/^(~|#)/g, "\\$1")
    .replace(/(\*|\?)/gu, "\\$1")
    .replace(/(\$|\;|\&|\|)/g, "\\$1")
    .replace(/(\(|\)|\<|\>)/g, "\\$1")
    .replace(/("|'|`)/g, "\\$1");

  if (shell.endsWith("zsh")) {
    result = result.replace(/^=/gu, "\\=").replace(/(\[|\]|\{|\})/g, "\\$1");
  }

  return result;
}

/**
 * Escape a shell argument.
 *
 * @param {string} arg The argument to escape.
 * @param {string} shell The shell to escape the argument for.
 * @param {boolean} interpolation Is interpolation enabled.
 * @returns {string} The escaped argument.
 */
function escapeShellArg$1(arg, shell, interpolation) {
  if (shell === undefined) throw new TypeError(shellRequiredError);

  if (interpolation) {
    return escapeShellArgWithInterpolation(arg, shell);
  } else {
    return escapeShellArgNoInterpolation(arg);
  }
}

/**
 * Get the default shell for Unix systems.
 *
 * @returns {string} The default shell.
 */
function getDefaultShell$1() {
  return "/bin/sh";
}

/**
 * @overview Contains functionality specifically for Windows systems.
 * @license MPL-2.0
 * @author Eric Cornelissen <ericornelissen@gmail.com>
 */

/**
 * Escape a shell argument for use in CMD.
 *
 * @param {string} arg The argument to escape.
 * @param {boolean} interpolation Is interpolation enabled.
 * @returns {string} The escaped argument.
 */
function escapeShellArgsForCmd(arg, interpolation) {
  let result = arg.replace(/\u{0}/gu, "");

  if (interpolation) {
    result = result
      .replace(/\^/g, "^^")
      .replace(/(<|>)/g, "^$1")
      .replace(/(")/g, "^$1")
      .replace(/(\&|\|)/g, "^$1");
  } else {
    result = result.replace(/"/g, `""`);
  }

  return result;
}

/**
 * Escape a shell argument for use in PowerShell.
 *
 * @param {string} arg The argument to escape.
 * @param {boolean} interpolation Is interpolation enabled.
 * @returns {string} The escaped argument.
 */
function escapeShellArgsForPowerShell(arg, interpolation) {
  let result = arg
    .replace(/\u{0}/gu, "")
    .replace(/`/g, "``")
    .replace(/\$/g, "`$");

  if (interpolation) {
    result = result
      .replace(/^((?:\*|[1-6])?)(>)/g, "$1`$2")
      .replace(/^(<|@|#|-|\:|\])/g, "`$1")
      .replace(/(,|\;|\&|\|)/g, "`$1")
      .replace(/(\(|\)|\{|\})/g, "`$1")
      .replace(/('|’|‘|‛|‚)/g, "`$1")
      .replace(/("|“|”|„)/g, "`$1");
  } else {
    result = result.replace(/("|“|”|„)/g, "$1$1");
  }

  return result;
}

/**
 * Escape a shell argument.
 *
 * @param {string} arg The argument to escape.
 * @param {string} shell The shell to escape the argument for.
 * @param {boolean} interpolation Is interpolation enabled.
 * @returns {string} The escaped argument.
 */
function escapeShellArg(arg, shell, interpolation) {
  if (shell === undefined) throw new TypeError(shellRequiredError);

  if (regexpPowerShell.test(shell)) {
    return escapeShellArgsForPowerShell(arg, interpolation);
  } else {
    return escapeShellArgsForCmd(arg, interpolation);
  }
}

/**
 * Get the default shell for Windows systems.
 *
 * @param {Object} env The environment variables.
 * @param {string} env.ComSpec The ComSpec value.
 * @returns {string} The default shell.
 */
function getDefaultShell(env) {
  return env.ComSpec;
}

/**
 * @overview Contains functionality to escape and quote shell arguments on any
 * operating system.
 * @license MPL-2.0
 * @author Eric Cornelissen <ericornelissen@gmail.com>
 */

/**
 * Check if a value can be converted into a string.
 *
 * @param {any} value The value of interest.
 * @returns {boolean} `true` iff `value` can be converted into a string.
 */
function isStringable(value) {
  if (value === undefined || value === null) {
    return false;
  }

  return typeof value.toString === "function";
}

/**
 * Get the shell to escape arguments for.
 *
 * @param {string} platform The platform to get the shell for.
 * @param {Object} env The environment variables.
 * @param {string} [shell] The provided shell, if any.
 * @returns The shell to escape arguments for.
 */
function getShell(platform, env, shell) {
  if (shell === undefined) {
    switch (platform) {
      case win32:
        shell = getDefaultShell(env);
        break;
      default:
        shell = getDefaultShell$1();
        break;
    }
  }

  return resolveExecutable(
    {
      executable: shell,
    },
    {
      exists: fs__namespace.existsSync,
      readlink: fs__namespace.readlinkSync,
      which: which__default["default"].sync,
    }
  );
}

/**
 * Take a value and escape any dangerous characters.
 *
 * Non-string inputs will be converted to strings using a `toString()` method.
 *
 * @param {string} arg The argument to escape.
 * @param {string} platform The platform to escape the argument for.
 * @param {Object} env The environment variables.
 * @param {string} [shell] The shell to escape the argument for, if any.
 * @param {boolean} [interpolation=false] Is interpolation enabled.
 * @returns {string} The escaped argument.
 * @throws {TypeError} The argument is not stringable.
 */
function escapeShellArgByPlatform(
  arg,
  platform,
  env,
  shell,
  interpolation = false
) {
  if (!isStringable(arg)) {
    throw new TypeError(typeError);
  }

  shell = getShell(platform, env, shell);
  const argAsString = arg.toString();
  switch (platform) {
    case win32:
      return escapeShellArg(argAsString, shell, interpolation);
    default:
      return escapeShellArg$1(argAsString, shell, interpolation);
  }
}

/**
 * Take a value, put OS-specific quotes around it, and escape any dangerous
 * characters.
 *
 * Non-string inputs will be converted to strings using a `toString()` method.
 *
 * @param {string} arg The argument to escape and quote.
 * @param {string} platform The platform to escape and quote the argument for.
 * @param {Object} env The environment variables.
 * @param {string} [shell] The shell to escape the argument for, if any.
 * @returns {string} The escaped argument.
 * @throws {TypeError} The argument is not stringable.
 */
function quoteShellArgByPlatform(arg, platform, env, shell) {
  const safeArg = escapeShellArgByPlatform(arg, platform, env, shell, false);
  switch (platform) {
    case win32:
      return `"${safeArg}"`;
    default:
      return `'${safeArg}'`;
  }
}

/**
 * A simple shell escape package. Use it to escape user-controlled inputs to
 * shell commands to prevent shell injection.
 *
 * @example
 *   import cp from "child_process";
 *   import * as shescape from "shescape";
 *   cp.spawn("command", shescape.escapeAll(userInput), options);
 *
 * @module shescape
 * @version 1.5.0
 * @license MPL-2.0
 * @author Eric Cornelissen <ericornelissen@gmail.com>
 */

/**
 * Take a single value, the argument, and escape any dangerous characters.
 *
 * Non-string inputs will be converted to strings using a `toString()` method.
 *
 * @param {string} arg The argument to escape.
 * @param {Object} [options] The escape options.
 * @param {string} [options.interpolation=false] Is interpolation enabled.
 * @param {string} [options.shell] The shell to escape the argument for.
 * @returns {string} The escaped argument.
 * @throws {TypeError} The argument is not stringable.
 * @since 0.1.0
 */
function escape(arg, options = {}) {
  const { interpolation, shell } = options;
  const env = process.env;
  const platform = os__default["default"].platform();
  return escapeShellArgByPlatform(
    arg,
    platform,
    env,
    shell,
    interpolation
  );
}

/**
 * Take a array of values, the arguments, and escape any dangerous characters in
 * every argument.
 *
 * Non-array inputs will be converted to one-value arrays and non-string values
 * will be converted to strings using a `toString()` method.
 *
 * @param {string[]} args The arguments to escape.
 * @param {Object} [options] The escape options.
 * @param {string} [options.interpolation=false] Is interpolation enabled.
 * @param {string} [options.shell] The shell to escape the arguments for.
 * @returns {string[]} The escaped arguments.
 * @throws {TypeError} One of the arguments is not stringable.
 * @since 1.1.0
 */
function escapeAll(args, options = {}) {
  if (!Array.isArray(args)) args = [args];

  const { interpolation, shell } = options;
  const env = process.env;
  const platform = os__default["default"].platform();
  const result = [];
  for (const arg of args) {
    const safeArg = escapeShellArgByPlatform(
      arg,
      platform,
      env,
      shell,
      interpolation
    );
    result.push(safeArg);
  }

  return result;
}

/**
 * Take a single value, the argument, put OS-specific quotes around it and
 * escape any dangerous characters.
 *
 * Non-string inputs will be converted to strings using a `toString()` method.
 *
 * @param {string} arg The argument to quote and escape.
 * @param {Object} [options] The escape and quote options.
 * @param {string} [options.shell] The shell to escape the argument for.
 * @returns {string} The quoted and escaped argument.
 * @throws {TypeError} The argument is not stringable.
 * @since 0.3.0
 */
function quote(arg, options = {}) {
  const shell = options.shell;
  const env = process.env;
  const platform = os__default["default"].platform();
  return quoteShellArgByPlatform(arg, platform, env, shell);
}

/**
 * Take an array of values, the arguments, put OS-specific quotes around every
 * argument and escape any dangerous characters in every argument.
 *
 * Non-array inputs will be converted to one-value arrays and non-string values
 * will be converted to strings using a `toString()` method.
 *
 * @param {string[]} args The arguments to quote and escape.
 * @param {Object} [options] The escape and quote options.
 * @param {string} [options.shell] The shell to escape the arguments for.
 * @returns {string[]} The quoted and escaped arguments.
 * @throws {TypeError} One of the arguments is not stringable.
 * @since 0.4.0
 */
function quoteAll(args, options = {}) {
  if (!Array.isArray(args)) args = [args];

  const shell = options.shell;
  const env = process.env;
  const platform = os__default["default"].platform();
  const result = [];
  for (const arg of args) {
    const safeArg = quoteShellArgByPlatform(arg, platform, env, shell);
    result.push(safeArg);
  }

  return result;
}

exports.escape = escape;
exports.escapeAll = escapeAll;
exports.quote = quote;
exports.quoteAll = quoteAll;
