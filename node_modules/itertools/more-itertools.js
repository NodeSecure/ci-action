"use strict";

var _regeneratorRuntime2 = require("@babel/runtime/regenerator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chunked = chunked;
exports.flatten = flatten;
exports.intersperse = intersperse;
exports.itake = itake;
exports.pairwise = pairwise;
exports.partition = partition;
exports.roundrobin = roundrobin;
exports.heads = heads;
exports.take = take;
exports.uniqueEverseen = uniqueEverseen;
exports.uniqueJustseen = uniqueJustseen;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _builtins = require("./builtins");

var _itertools = require("./itertools");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _marked = /*#__PURE__*/_regeneratorRuntime2.mark(chunked),
    _marked2 = /*#__PURE__*/_regeneratorRuntime2.mark(flatten),
    _marked3 = /*#__PURE__*/_regeneratorRuntime2.mark(itake),
    _marked4 = /*#__PURE__*/_regeneratorRuntime2.mark(pairwise),
    _marked5 = /*#__PURE__*/_regeneratorRuntime2.mark(roundrobin),
    _marked6 = /*#__PURE__*/_regeneratorRuntime2.mark(heads),
    _marked7 = /*#__PURE__*/_regeneratorRuntime2.mark(uniqueEverseen),
    _marked8 = /*#__PURE__*/_regeneratorRuntime2.mark(uniqueJustseen);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Break iterable into lists of length `size`:
 *
 *     [...chunked([1, 2, 3, 4, 5, 6], 3)]
 *     // [[1, 2, 3], [4, 5, 6]]
 *
 * If the length of iterable is not evenly divisible by `size`, the last returned
 * list will be shorter:
 *
 *     [...chunked([1, 2, 3, 4, 5, 6, 7, 8], 3)]
 *     // [[1, 2, 3], [4, 5, 6], [7, 8]]
 */
function chunked(iterable, size) {
  var it, r1, chunk, _iterator, _step, item;

  return _regenerator["default"].wrap(function chunked$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          it = (0, _builtins.iter)(iterable);
          r1 = it.next();

          if (!r1.done) {
            _context.next = 4;
            break;
          }

          return _context.abrupt("return");

        case 4:
          chunk = [r1.value];
          _iterator = _createForOfIteratorHelper(it);
          _context.prev = 6;

          _iterator.s();

        case 8:
          if ((_step = _iterator.n()).done) {
            _context.next = 17;
            break;
          }

          item = _step.value;
          chunk.push(item);

          if (!(chunk.length === size)) {
            _context.next = 15;
            break;
          }

          _context.next = 14;
          return chunk;

        case 14:
          chunk = [];

        case 15:
          _context.next = 8;
          break;

        case 17:
          _context.next = 22;
          break;

        case 19:
          _context.prev = 19;
          _context.t0 = _context["catch"](6);

          _iterator.e(_context.t0);

        case 22:
          _context.prev = 22;

          _iterator.f();

          return _context.finish(22);

        case 25:
          if (!(chunk.length > 0)) {
            _context.next = 28;
            break;
          }

          _context.next = 28;
          return chunk;

        case 28:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[6, 19, 22, 25]]);
}
/**
 * Return an iterator flattening one level of nesting in a list of lists:
 *
 *     [...flatten([[0, 1], [2, 3]])]
 *     // [0, 1, 2, 3]
 *
 */


function flatten(iterableOfIterables) {
  var _iterator2, _step2, iterable, _iterator3, _step3, item;

  return _regenerator["default"].wrap(function flatten$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _iterator2 = _createForOfIteratorHelper(iterableOfIterables);
          _context2.prev = 1;

          _iterator2.s();

        case 3:
          if ((_step2 = _iterator2.n()).done) {
            _context2.next = 24;
            break;
          }

          iterable = _step2.value;
          _iterator3 = _createForOfIteratorHelper(iterable);
          _context2.prev = 6;

          _iterator3.s();

        case 8:
          if ((_step3 = _iterator3.n()).done) {
            _context2.next = 14;
            break;
          }

          item = _step3.value;
          _context2.next = 12;
          return item;

        case 12:
          _context2.next = 8;
          break;

        case 14:
          _context2.next = 19;
          break;

        case 16:
          _context2.prev = 16;
          _context2.t0 = _context2["catch"](6);

          _iterator3.e(_context2.t0);

        case 19:
          _context2.prev = 19;

          _iterator3.f();

          return _context2.finish(19);

        case 22:
          _context2.next = 3;
          break;

        case 24:
          _context2.next = 29;
          break;

        case 26:
          _context2.prev = 26;
          _context2.t1 = _context2["catch"](1);

          _iterator2.e(_context2.t1);

        case 29:
          _context2.prev = 29;

          _iterator2.f();

          return _context2.finish(29);

        case 32:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[1, 26, 29, 32], [6, 16, 19, 22]]);
}
/**
 * Intersperse filler element `value` among the items in `iterable`.
 *
 *     >>> [...intersperse(-1, range(1, 5))]
 *     [1, -1, 2, -1, 3, -1, 4]
 *
 */


function intersperse(value, iterable) {
  var stream = flatten((0, _itertools.izip)((0, _itertools.repeat)(value), iterable));
  take(1, stream); // eat away and discard the first value from the output

  return stream;
}
/**
 * Returns an iterable containing only the first `n` elements of the given
 * iterable.
 */


function itake(n, iterable) {
  var it, count, s;
  return _regenerator["default"].wrap(function itake$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          it = (0, _builtins.iter)(iterable);
          count = n;

        case 2:
          if (!(count-- > 0)) {
            _context3.next = 12;
            break;
          }

          s = it.next();

          if (s.done) {
            _context3.next = 9;
            break;
          }

          _context3.next = 7;
          return s.value;

        case 7:
          _context3.next = 10;
          break;

        case 9:
          return _context3.abrupt("return");

        case 10:
          _context3.next = 2;
          break;

        case 12:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
/**
 * Returns an iterator of paired items, overlapping, from the original.  When
 * the input iterable has a finite number of items `n`, the outputted iterable
 * will have `n - 1` items.
 *
 *     >>> pairwise([8, 2, 0, 7])
 *     [(8, 2), (2, 0), (0, 7)]
 *
 */


function pairwise(iterable) {
  var it, r1, _iterator4, _step4, r2;

  return _regenerator["default"].wrap(function pairwise$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          it = (0, _builtins.iter)(iterable);
          r1 = it.next();

          if (!r1.done) {
            _context4.next = 4;
            break;
          }

          return _context4.abrupt("return");

        case 4:
          r1 = r1.value;
          _iterator4 = _createForOfIteratorHelper(it);
          _context4.prev = 6;

          _iterator4.s();

        case 8:
          if ((_step4 = _iterator4.n()).done) {
            _context4.next = 15;
            break;
          }

          r2 = _step4.value;
          _context4.next = 12;
          return [r1, r2];

        case 12:
          r1 = r2;

        case 13:
          _context4.next = 8;
          break;

        case 15:
          _context4.next = 20;
          break;

        case 17:
          _context4.prev = 17;
          _context4.t0 = _context4["catch"](6);

          _iterator4.e(_context4.t0);

        case 20:
          _context4.prev = 20;

          _iterator4.f();

          return _context4.finish(20);

        case 23:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[6, 17, 20, 23]]);
}
/**
 * Returns a 2-tuple of arrays.  Splits the elements in the input iterable into
 * either of the two arrays.  Will fully exhaust the input iterable.  The first
 * array contains all items that match the predicate, the second the rest:
 *
 *     >>> const isOdd = x => x % 2 !== 0;
 *     >>> const iterable = range(10);
 *     >>> const [odds, evens] = partition(iterable, isOdd);
 *     >>> odds
 *     [1, 3, 5, 7, 9]
 *     >>> evens
 *     [0, 2, 4, 6, 8]
 *
 */


function partition(iterable, predicate) {
  var good = [];
  var bad = [];

  var _iterator5 = _createForOfIteratorHelper(iterable),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var item = _step5.value;

      if (predicate(item)) {
        good.push(item);
      } else {
        bad.push(item);
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return [good, bad];
}
/**
 * Yields the next item from each iterable in turn, alternating between them.
 * Continues until all items are exhausted.
 *
 *     >>> [...roundrobin([1, 2, 3], [4], [5, 6, 7, 8])]
 *     [1, 4, 5, 2, 6, 3, 7, 8]
 */


function roundrobin() {
  var _len,
      iters,
      _key,
      iterables,
      index,
      it,
      result,
      _args5 = arguments;

  return _regenerator["default"].wrap(function roundrobin$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          for (_len = _args5.length, iters = new Array(_len), _key = 0; _key < _len; _key++) {
            iters[_key] = _args5[_key];
          }

          // We'll only keep lazy versions of the input iterables in here that we'll
          // slowly going to exhaust.  Once an iterable is exhausted, it will be
          // removed from this list.  Once the entire list is empty, this algorithm
          // ends.
          iterables = (0, _builtins.map)(iters, _builtins.iter);

        case 2:
          if (!(iterables.length > 0)) {
            _context5.next = 18;
            break;
          }

          index = 0;

        case 4:
          if (!(index < iterables.length)) {
            _context5.next = 16;
            break;
          }

          it = iterables[index];
          result = it.next();

          if (result.done) {
            _context5.next = 13;
            break;
          }

          _context5.next = 10;
          return result.value;

        case 10:
          index++;
          _context5.next = 14;
          break;

        case 13:
          // This iterable is exhausted, make sure to remove it from the
          // list of iterables.  We'll splice the array from under our
          // feet, and NOT advancing the index counter.
          iterables.splice(index, 1); // intentional side-effect!

        case 14:
          _context5.next = 4;
          break;

        case 16:
          _context5.next = 2;
          break;

        case 18:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}
/**
 * Yields the heads of all of the given iterables.  This is almost like
 * `roundrobin()`, except that the yielded outputs are grouped in to the
 * "rounds":
 *
 *     >>> [...heads([1, 2, 3], [4], [5, 6, 7, 8])]
 *     [[1, 4, 5], [2, 6], [3, 7], [8]]
 *
 * This is also different from `zipLongest()`, since the number of items in
 * each round can decrease over time, rather than being filled with a filler.
 */


function heads() {
  var _len2,
      iters,
      _key2,
      iterables,
      index,
      round,
      it,
      result,
      _args6 = arguments;

  return _regenerator["default"].wrap(function heads$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          for (_len2 = _args6.length, iters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            iters[_key2] = _args6[_key2];
          }

          // We'll only keep lazy versions of the input iterables in here that we'll
          // slowly going to exhaust.  Once an iterable is exhausted, it will be
          // removed from this list.  Once the entire list is empty, this algorithm
          // ends.
          iterables = (0, _builtins.map)(iters, _builtins.iter);

        case 2:
          if (!(iterables.length > 0)) {
            _context6.next = 11;
            break;
          }

          index = 0;
          round = [];

          while (index < iterables.length) {
            it = iterables[index];
            result = it.next();

            if (!result.done) {
              round.push(result.value);
              index++;
            } else {
              // This iterable is exhausted, make sure to remove it from the
              // list of iterables.  We'll splice the array from under our
              // feet, and NOT advancing the index counter.
              iterables.splice(index, 1); // intentional side-effect!
            }
          }

          if (!(round.length > 0)) {
            _context6.next = 9;
            break;
          }

          _context6.next = 9;
          return round;

        case 9:
          _context6.next = 2;
          break;

        case 11:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6);
}
/**
 * Non-lazy version of itake().
 */


function take(n, iterable) {
  return Array.from(itake(n, iterable));
}
/**
 * Yield unique elements, preserving order.
 *
 *     >>> [...uniqueEverseen('AAAABBBCCDAABBB')]
 *     ['A', 'B', 'C', 'D']
 *     >>> [...uniqueEverseen('AbBCcAB', s => s.toLowerCase())]
 *     ['A', 'b', 'C']
 *
 */


function uniqueEverseen(iterable) {
  var keyFn,
      seen,
      _iterator6,
      _step6,
      item,
      key,
      _args7 = arguments;

  return _regenerator["default"].wrap(function uniqueEverseen$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          keyFn = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : _utils.primitiveIdentity;
          seen = new Set();
          _iterator6 = _createForOfIteratorHelper(iterable);
          _context7.prev = 3;

          _iterator6.s();

        case 5:
          if ((_step6 = _iterator6.n()).done) {
            _context7.next = 14;
            break;
          }

          item = _step6.value;
          key = keyFn(item);

          if (seen.has(key)) {
            _context7.next = 12;
            break;
          }

          seen.add(key);
          _context7.next = 12;
          return item;

        case 12:
          _context7.next = 5;
          break;

        case 14:
          _context7.next = 19;
          break;

        case 16:
          _context7.prev = 16;
          _context7.t0 = _context7["catch"](3);

          _iterator6.e(_context7.t0);

        case 19:
          _context7.prev = 19;

          _iterator6.f();

          return _context7.finish(19);

        case 22:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked7, null, [[3, 16, 19, 22]]);
}
/**
 * Yields elements in order, ignoring serial duplicates.
 *
 *     >>> [...uniqueJustseen('AAAABBBCCDAABBB')]
 *     ['A', 'B', 'C', 'D', 'A', 'B']
 *     >>> [...uniqueJustseen('AbBCcAB', s => s.toLowerCase())]
 *     ['A', 'b', 'C', 'A', 'B']
 *
 */


function uniqueJustseen(iterable) {
  var keyFn,
      last,
      _iterator7,
      _step7,
      item,
      key,
      _args8 = arguments;

  return _regenerator["default"].wrap(function uniqueJustseen$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          keyFn = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : _utils.primitiveIdentity;
          last = undefined;
          _iterator7 = _createForOfIteratorHelper(iterable);
          _context8.prev = 3;

          _iterator7.s();

        case 5:
          if ((_step7 = _iterator7.n()).done) {
            _context8.next = 14;
            break;
          }

          item = _step7.value;
          key = keyFn(item);

          if (!(key !== last)) {
            _context8.next = 12;
            break;
          }

          _context8.next = 11;
          return item;

        case 11:
          last = key;

        case 12:
          _context8.next = 5;
          break;

        case 14:
          _context8.next = 19;
          break;

        case 16:
          _context8.prev = 16;
          _context8.t0 = _context8["catch"](3);

          _iterator7.e(_context8.t0);

        case 19:
          _context8.prev = 19;

          _iterator7.f();

          return _context8.finish(19);

        case 22:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked8, null, [[3, 16, 19, 22]]);
}