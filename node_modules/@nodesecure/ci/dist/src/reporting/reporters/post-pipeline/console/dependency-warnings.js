// Import Third-party Dependencies
import pluralize from "pluralize";
import { match } from "ts-pattern";
// Import Internal Dependencies
import { consolePrinter } from "../../../../../lib/console-printer/index.js";
import { Nsci } from "../../../../configuration/index.js";
import { buildOutcomeStatsConsoleMessage, getOutcomeEmoji, printWarnOrError } from "./util.js";
function collectDependencyWarningsConsoleMessages(dependenciesWarnings) {
    const warningsWithErrorMode = [];
    const warningsWithWarningMode = [];
    const warningsToPrint = [];
    for (const dependencyWarning of dependenciesWarnings) {
        for (const warning of dependencyWarning.warnings) {
            /**
             * Collect information about "warning" and "error" stats that can be used
             * in the reporting process
             */
            if (warning.mode === Nsci.warnings.ERROR) {
                warningsWithErrorMode.push(dependencyWarning);
            }
            else {
                warningsWithWarningMode.push(dependencyWarning);
            }
            let warningLocation;
            let warningPath;
            if (warning.file) {
                warningPath = consolePrinter.font.standard(`${dependencyWarning.package ?? "."}/${warning.file}`).message;
                warningLocation = consolePrinter.font.info(`${warning.location.flatMap((location) => location.join(":"))}`).message;
            }
            // Don't directly print messages to defer the console rendering at
            // another point in time
            warningsToPrint.push(consolePrinter.util.concatOutputs([
                printWarnOrError(warning.mode)(warning.kind).bold().underline()
                    .message,
                warningLocation && warningPath
                    ? `${warningPath}:${warningLocation}`
                    : ""
            ]));
        }
    }
    function printAllWarnings() {
        warningsToPrint.forEach((warning) => warning.printWithEmptyLine());
    }
    return {
        warningsWithErrorMode,
        warningsWithWarningMode,
        printAllWarnings
    };
}
export function reportDependencyWarnings(warnings, warningsMode) {
    const numberOfDependencyWarnings = warnings.reduce((accumulatedNumberOfWarnings, dependencyWarning) => accumulatedNumberOfWarnings + dependencyWarning.warnings.length, 0);
    const { warningsWithErrorMode, printAllWarnings } = collectDependencyWarningsConsoleMessages(warnings);
    if (warningsMode === Nsci.warnings.OFF) {
        consolePrinter.font
            .info(`⚠ dependency warnings were skipped`)
            .bold()
            .printWithEmptyLine();
        return;
    }
    if (numberOfDependencyWarnings === 0) {
        consolePrinter.font
            .success(`✓ 0 dependency warnings`)
            .bold()
            .printWithEmptyLine();
        return;
    }
    const dependencyWarningsOutcome = `${numberOfDependencyWarnings} dependency ${pluralize("warning", numberOfDependencyWarnings)}`;
    if (warningsMode === Nsci.warnings.ERROR ||
        warningsMode === Nsci.warnings.WARNING) {
        const outcomeEmoji = getOutcomeEmoji(warningsMode);
        printWarnOrError(warningsMode)(`${outcomeEmoji} ${dependencyWarningsOutcome}`)
            .bold()
            .printWithEmptyLine();
        printAllWarnings();
        return;
    }
    /**
     * The last specific warning mode to display is the Record mode:
     * If there is atleast one "error" warning defined in the Record that is
     * encountered, the whole message will be printed in Error (red). Otherwise if
     * there is no "error" warning, the whole message will be printed in Warning (yellow).
     */
    const warningOrErrorMode = warningsWithErrorMode.length > 0
        ? Nsci.warnings.ERROR
        : Nsci.warnings.WARNING;
    const outcomeEmoji = getOutcomeEmoji(warningOrErrorMode);
    printWarnOrError(warningOrErrorMode)(`${outcomeEmoji} ${dependencyWarningsOutcome}`)
        .bold()
        .printWithEmptyLine();
    printAllWarnings();
}
function collectNumberOfWarningsWithError(dependencyWarning) {
    return dependencyWarning.warnings.filter((warning) => warning.mode === Nsci.warnings.ERROR).length;
}
function collectDependencyWarningsStats(warnings) {
    const dependencyWarningsStats = warnings.reduce((accumulatedWarningsStats, dependencyWarning) => {
        return {
            allWarnings: accumulatedWarningsStats.allWarnings +
                dependencyWarning.warnings.length,
            warningsWithError: accumulatedWarningsStats.warningsWithError +
                collectNumberOfWarningsWithError(dependencyWarning)
        };
    }, { allWarnings: 0, warningsWithError: 0 });
    return dependencyWarningsStats;
}
export function buildDependenciesWarningsOutcomeMessage(warnings, warningsMode) {
    const { allWarnings, warningsWithError } = collectDependencyWarningsStats(warnings);
    return match(warningsMode)
        .with(Nsci.warnings.OFF, () => consolePrinter.font.info("⚠ dependency warnings skipped"))
        .with(Nsci.warnings.ERROR, () => buildOutcomeStatsConsoleMessage(allWarnings, Nsci.warnings.ERROR))
        .with(Nsci.warnings.WARNING, () => buildOutcomeStatsConsoleMessage(allWarnings, Nsci.warnings.WARNING))
        .otherwise(() => buildOutcomeStatsConsoleMessage(allWarnings, 
    // eslint-disable-next-line no-nested-ternary
    warningsWithError > 0
        ? Nsci.warnings.ERROR
        : allWarnings > 0
            ? Nsci.warnings.WARNING
            : Nsci.warnings.OFF));
}
//# sourceMappingURL=dependency-warnings.js.map