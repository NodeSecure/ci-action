"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Import Node.js Dependencies
const util_1 = require("util");
// VARS
const setTimeoutAysnc = (0, util_1.promisify)(setTimeout);
// CONSTANTS
const kDefaultOperationOptions = {
    retries: 3,
    minTimeout: 1000,
    maxTimeout: Infinity,
    forever: false,
    unref: false,
    factor: 2,
    signal: null
};
class Operation {
    constructor(options) {
        this.continueExecution = true;
        this.attempt = 0;
        this.startAt = Date.now();
        this.elapsedTimeoutTime = 0;
        Object.assign(this, {}, kDefaultOperationOptions, options);
        if (this.forever) {
            this.retries = Infinity;
        }
    }
    /**
     * @see http://dthain.blogspot.com/2009/02/exponential-backoff-in-distributed.html
     */
    get backoff() {
        return Math.min(this.minTimeout * Math.pow(this.factor, this.attempt - 1), this.maxTimeout);
    }
    get continue() {
        return this.continueExecution;
    }
    ensureAbort() {
        if (this.signal === null) {
            return;
        }
        if (this.signal.aborted) {
            throw new Error("Aborted");
        }
    }
    async retry() {
        var _a;
        this.ensureAbort();
        this.attempt++;
        if (this.attempt > this.retries) {
            // TODO: add error causes ?
            throw new Error("Exceeded the maximum number of allowed retries!");
        }
        const timeout = this.backoff;
        const signal = (_a = this.signal) !== null && _a !== void 0 ? _a : void 0;
        this.continueExecution = true;
        await setTimeoutAysnc(timeout, void 0, { ref: this.unref, signal });
        this.ensureAbort();
        this.elapsedTimeoutTime += timeout;
    }
    success(data) {
        this.data = data;
        this.continueExecution = false;
        this.executionTimestamp = Date.now() - this.startAt;
    }
    toJSON() {
        return {
            data: this.data,
            metrics: {
                attempt: this.attempt,
                executionTimestamp: this.executionTimestamp,
                elapsedTimeoutTime: this.elapsedTimeoutTime
            }
        };
    }
}
exports.default = Operation;
//# sourceMappingURL=Operation.class.js.map