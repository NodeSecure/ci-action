"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.chain = chain;
exports.count = count;
exports.compress = compress;
exports.cycle = cycle;
exports.dropwhile = dropwhile;
exports.groupby = groupby;
exports.icompress = icompress;
exports.ifilter = ifilter;
exports.imap = imap;
exports.islice = islice;
exports.izip2 = izip2;
exports.izip3 = izip3;
exports.izipLongest2 = izipLongest2;
exports.izipLongest3 = izipLongest3;
exports.izipMany = izipMany;
exports.permutations = permutations;
exports.repeat = repeat;
exports.takewhile = takewhile;
exports.zipLongest2 = zipLongest2;
exports.zipLongest3 = zipLongest3;
exports.zipMany = zipMany;
exports.zipLongest = exports.izipLongest = exports.izip = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _builtins = require("./builtins");

var _moreItertools = require("./more-itertools");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _marked = /*#__PURE__*/_regenerator["default"].mark(count),
    _marked2 = /*#__PURE__*/_regenerator["default"].mark(cycle),
    _marked3 = /*#__PURE__*/_regenerator["default"].mark(dropwhile),
    _marked4 = /*#__PURE__*/_regenerator["default"].mark(groupby),
    _marked5 = /*#__PURE__*/_regenerator["default"].mark(icompress),
    _marked6 = /*#__PURE__*/_regenerator["default"].mark(ifilter),
    _marked7 = /*#__PURE__*/_regenerator["default"].mark(imap),
    _marked8 = /*#__PURE__*/_regenerator["default"].mark(islice),
    _marked9 = /*#__PURE__*/_regenerator["default"].mark(izip2),
    _marked10 = /*#__PURE__*/_regenerator["default"].mark(izip3),
    _marked11 = /*#__PURE__*/_regenerator["default"].mark(izipLongest2),
    _marked12 = /*#__PURE__*/_regenerator["default"].mark(izipLongest3),
    _marked13 = /*#__PURE__*/_regenerator["default"].mark(izipMany),
    _marked14 = /*#__PURE__*/_regenerator["default"].mark(permutations),
    _marked15 = /*#__PURE__*/_regenerator["default"].mark(repeat),
    _marked16 = /*#__PURE__*/_regenerator["default"].mark(takewhile);

var SENTINEL = Symbol();

function composeAnd(f1, f2) {
  return function (n) {
    return f1(n) && f2(n);
  };
}

function slicePredicate(start, stop, step) {
  // If stop is not provided (= undefined), then interpret the start value as the stop value
  var _start = start,
      _stop = stop,
      _step = step;

  if (_stop === undefined) {
    var _ref = [0, _start];
    _start = _ref[0];
    _stop = _ref[1];
  }

  var pred = function pred(n) {
    return n >= _start;
  };

  if (_stop !== null) {
    var stopNotNull = _stop;
    pred = composeAnd(pred, function (n) {
      return n < stopNotNull;
    });
  }

  if (_step > 1) {
    pred = composeAnd(pred, function (n) {
      return (n - _start) % _step === 0;
    });
  }

  return pred;
}
/**
 * Returns an iterator that returns elements from the first iterable until it
 * is exhausted, then proceeds to the next iterable, until all of the iterables
 * are exhausted.  Used for treating consecutive sequences as a single
 * sequence.
 */


function chain() {
  for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {
    iterables[_key] = arguments[_key];
  }

  return (0, _moreItertools.flatten)(iterables);
}
/**
 * Returns an iterator that counts up values starting with number `start`
 * (default 0), incrementing by `step`.  To decrement, use a negative step
 * number.
 */


function count() {
  var start,
      step,
      n,
      _args = arguments;
  return _regenerator["default"].wrap(function count$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          start = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;
          step = _args.length > 1 && _args[1] !== undefined ? _args[1] : 1;
          n = start;

        case 3:
          _context.next = 5;
          return n;

        case 5:
          n += step;

        case 6:
          _context.next = 3;
          break;

        case 8:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 * Non-lazy version of icompress().
 */


function compress(data, selectors) {
  return Array.from(icompress(data, selectors));
}
/**
 * Returns an iterator producing elements from the iterable and saving a copy
 * of each.  When the iterable is exhausted, return elements from the saved
 * copy.  Repeats indefinitely.
 */


function cycle(iterable) {
  var saved, _iterator, _step2, _element, _iterator2, _step3, element;

  return _regenerator["default"].wrap(function cycle$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          saved = [];
          _iterator = _createForOfIteratorHelper(iterable);
          _context2.prev = 2;

          _iterator.s();

        case 4:
          if ((_step2 = _iterator.n()).done) {
            _context2.next = 11;
            break;
          }

          _element = _step2.value;
          _context2.next = 8;
          return _element;

        case 8:
          saved.push(_element);

        case 9:
          _context2.next = 4;
          break;

        case 11:
          _context2.next = 16;
          break;

        case 13:
          _context2.prev = 13;
          _context2.t0 = _context2["catch"](2);

          _iterator.e(_context2.t0);

        case 16:
          _context2.prev = 16;

          _iterator.f();

          return _context2.finish(16);

        case 19:
          if (!(saved.length > 0)) {
            _context2.next = 39;
            break;
          }

          _iterator2 = _createForOfIteratorHelper(saved);
          _context2.prev = 21;

          _iterator2.s();

        case 23:
          if ((_step3 = _iterator2.n()).done) {
            _context2.next = 29;
            break;
          }

          element = _step3.value;
          _context2.next = 27;
          return element;

        case 27:
          _context2.next = 23;
          break;

        case 29:
          _context2.next = 34;
          break;

        case 31:
          _context2.prev = 31;
          _context2.t1 = _context2["catch"](21);

          _iterator2.e(_context2.t1);

        case 34:
          _context2.prev = 34;

          _iterator2.f();

          return _context2.finish(34);

        case 37:
          _context2.next = 19;
          break;

        case 39:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[2, 13, 16, 19], [21, 31, 34, 37]]);
}
/**
 * Returns an iterator that drops elements from the iterable as long as the
 * predicate is true; afterwards, returns every remaining element.  Note, the
 * iterator does not produce any output until the predicate first becomes
 * false.
 */


function dropwhile(iterable, predicate) {
  var it, _iterator3, _step4, value, _iterator4, _step5, _value;

  return _regenerator["default"].wrap(function dropwhile$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          it = (0, _builtins.iter)(iterable);
          _iterator3 = _createForOfIteratorHelper(it);
          _context3.prev = 2;

          _iterator3.s();

        case 4:
          if ((_step4 = _iterator3.n()).done) {
            _context3.next = 12;
            break;
          }

          value = _step4.value;

          if (predicate(value)) {
            _context3.next = 10;
            break;
          }

          _context3.next = 9;
          return value;

        case 9:
          return _context3.abrupt("break", 12);

        case 10:
          _context3.next = 4;
          break;

        case 12:
          _context3.next = 17;
          break;

        case 14:
          _context3.prev = 14;
          _context3.t0 = _context3["catch"](2);

          _iterator3.e(_context3.t0);

        case 17:
          _context3.prev = 17;

          _iterator3.f();

          return _context3.finish(17);

        case 20:
          _iterator4 = _createForOfIteratorHelper(it);
          _context3.prev = 21;

          _iterator4.s();

        case 23:
          if ((_step5 = _iterator4.n()).done) {
            _context3.next = 29;
            break;
          }

          _value = _step5.value;
          _context3.next = 27;
          return _value;

        case 27:
          _context3.next = 23;
          break;

        case 29:
          _context3.next = 34;
          break;

        case 31:
          _context3.prev = 31;
          _context3.t1 = _context3["catch"](21);

          _iterator4.e(_context3.t1);

        case 34:
          _context3.prev = 34;

          _iterator4.f();

          return _context3.finish(34);

        case 37:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3, null, [[2, 14, 17, 20], [21, 31, 34, 37]]);
}

function groupby(iterable) {
  var keyFn,
      it,
      currentValue,
      currentKey,
      targetKey,
      grouper,
      nextVal,
      _args5 = arguments;
  return _regenerator["default"].wrap(function groupby$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          keyFn = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : _utils.primitiveIdentity;
          it = (0, _builtins.iter)(iterable);
          // $FlowFixMe[incompatible-type] - deliberate use of the SENTINEL symbol
          currentKey = SENTINEL;
          targetKey = currentKey;
          grouper = /*#__PURE__*/_regenerator["default"].mark(function grouper(tgtKey) {
            var nextVal;
            return _regenerator["default"].wrap(function grouper$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(currentKey === tgtKey)) {
                      _context4.next = 10;
                      break;
                    }

                    _context4.next = 3;
                    return currentValue;

                  case 3:
                    nextVal = it.next();

                    if (!nextVal.done) {
                      _context4.next = 6;
                      break;
                    }

                    return _context4.abrupt("return");

                  case 6:
                    currentValue = nextVal.value;
                    currentKey = keyFn(currentValue);
                    _context4.next = 0;
                    break;

                  case 10:
                  case "end":
                    return _context4.stop();
                }
              }
            }, grouper);
          });

        case 5:
          if (!(currentKey === targetKey)) {
            _context5.next = 14;
            break;
          }

          nextVal = it.next();

          if (!nextVal.done) {
            _context5.next = 10;
            break;
          }

          // $FlowFixMe[incompatible-type] - deliberate use of the SENTINEL symbol
          currentKey = SENTINEL;
          return _context5.abrupt("return");

        case 10:
          currentValue = nextVal.value;
          currentKey = keyFn(currentValue);
          _context5.next = 5;
          break;

        case 14:
          targetKey = currentKey;
          _context5.next = 17;
          return [currentKey, grouper(targetKey)];

        case 17:
          _context5.next = 5;
          break;

        case 19:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked4);
}
/**
 * Returns an iterator that filters elements from data returning only those
 * that have a corresponding element in selectors that evaluates to `true`.
 * Stops when either the data or selectors iterables has been exhausted.
 */


function icompress(data, selectors) {
  var _iterator5, _step6, _step6$value, d, s;

  return _regenerator["default"].wrap(function icompress$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _iterator5 = _createForOfIteratorHelper(izip(data, selectors));
          _context6.prev = 1;

          _iterator5.s();

        case 3:
          if ((_step6 = _iterator5.n()).done) {
            _context6.next = 10;
            break;
          }

          _step6$value = _slicedToArray(_step6.value, 2), d = _step6$value[0], s = _step6$value[1];

          if (!s) {
            _context6.next = 8;
            break;
          }

          _context6.next = 8;
          return d;

        case 8:
          _context6.next = 3;
          break;

        case 10:
          _context6.next = 15;
          break;

        case 12:
          _context6.prev = 12;
          _context6.t0 = _context6["catch"](1);

          _iterator5.e(_context6.t0);

        case 15:
          _context6.prev = 15;

          _iterator5.f();

          return _context6.finish(15);

        case 18:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked5, null, [[1, 12, 15, 18]]);
}
/**
 * Returns an iterator that filters elements from iterable returning only those
 * for which the predicate is true.
 */


function ifilter(iterable, predicate) {
  var _iterator6, _step7, value;

  return _regenerator["default"].wrap(function ifilter$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          _iterator6 = _createForOfIteratorHelper(iterable);
          _context7.prev = 1;

          _iterator6.s();

        case 3:
          if ((_step7 = _iterator6.n()).done) {
            _context7.next = 10;
            break;
          }

          value = _step7.value;

          if (!predicate(value)) {
            _context7.next = 8;
            break;
          }

          _context7.next = 8;
          return value;

        case 8:
          _context7.next = 3;
          break;

        case 10:
          _context7.next = 15;
          break;

        case 12:
          _context7.prev = 12;
          _context7.t0 = _context7["catch"](1);

          _iterator6.e(_context7.t0);

        case 15:
          _context7.prev = 15;

          _iterator6.f();

          return _context7.finish(15);

        case 18:
        case "end":
          return _context7.stop();
      }
    }
  }, _marked6, null, [[1, 12, 15, 18]]);
}
/**
 * Returns an iterator that computes the given mapper function using arguments
 * from each of the iterables.
 */


function imap(iterable, mapper) {
  var _iterator7, _step8, value;

  return _regenerator["default"].wrap(function imap$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _iterator7 = _createForOfIteratorHelper(iterable);
          _context8.prev = 1;

          _iterator7.s();

        case 3:
          if ((_step8 = _iterator7.n()).done) {
            _context8.next = 9;
            break;
          }

          value = _step8.value;
          _context8.next = 7;
          return mapper(value);

        case 7:
          _context8.next = 3;
          break;

        case 9:
          _context8.next = 14;
          break;

        case 11:
          _context8.prev = 11;
          _context8.t0 = _context8["catch"](1);

          _iterator7.e(_context8.t0);

        case 14:
          _context8.prev = 14;

          _iterator7.f();

          return _context8.finish(14);

        case 17:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked7, null, [[1, 11, 14, 17]]);
}
/**
 * Returns an iterator that returns selected elements from the iterable.  If
 * `start` is non-zero, then elements from the iterable are skipped until start
 * is reached.  Then, elements are returned by making steps of `step` (defaults
 * to 1).  If set to higher than 1, items will be skipped.  If `stop` is
 * provided, then iteration continues until the iterator reached that index,
 * otherwise, the iterable will be fully exhausted.  `islice()` does not
 * support negative values for `start`, `stop`, or `step`.
 */


function islice(iterable, start, stop) {
  var step,
      pred,
      _iterator8,
      _step9,
      _step9$value,
      i,
      value,
      _args9 = arguments;

  return _regenerator["default"].wrap(function islice$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          step = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : 1;

          if (!(start < 0)) {
            _context9.next = 3;
            break;
          }

          throw new Error('start cannot be negative');

        case 3:
          if (!(typeof stop === 'number' && stop < 0)) {
            _context9.next = 5;
            break;
          }

          throw new Error('stop cannot be negative');

        case 5:
          if (!(step < 0)) {
            _context9.next = 7;
            break;
          }

          throw new Error('step cannot be negative');

        case 7:
          pred = slicePredicate(start, stop, step);
          _iterator8 = _createForOfIteratorHelper((0, _builtins.enumerate)(iterable));
          _context9.prev = 9;

          _iterator8.s();

        case 11:
          if ((_step9 = _iterator8.n()).done) {
            _context9.next = 18;
            break;
          }

          _step9$value = _slicedToArray(_step9.value, 2), i = _step9$value[0], value = _step9$value[1];

          if (!pred(i)) {
            _context9.next = 16;
            break;
          }

          _context9.next = 16;
          return value;

        case 16:
          _context9.next = 11;
          break;

        case 18:
          _context9.next = 23;
          break;

        case 20:
          _context9.prev = 20;
          _context9.t0 = _context9["catch"](9);

          _iterator8.e(_context9.t0);

        case 23:
          _context9.prev = 23;

          _iterator8.f();

          return _context9.finish(23);

        case 26:
        case "end":
          return _context9.stop();
      }
    }
  }, _marked8, null, [[9, 20, 23, 26]]);
}
/**
 * Returns an iterator that aggregates elements from each of the iterables.
 * Used for lock-step iteration over several iterables at a time.  When
 * iterating over two iterables, use `izip2`.  When iterating over three
 * iterables, use `izip3`, etc.  `izip` is an alias for `izip2`.
 */


function izip2(xs, ys) {
  var ixs, iys, x, y;
  return _regenerator["default"].wrap(function izip2$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          ixs = (0, _builtins.iter)(xs);
          iys = (0, _builtins.iter)(ys);

        case 2:
          x = ixs.next();
          y = iys.next();

          if (!(!x.done && !y.done)) {
            _context10.next = 9;
            break;
          }

          _context10.next = 7;
          return [x.value, y.value];

        case 7:
          _context10.next = 10;
          break;

        case 9:
          return _context10.abrupt("return");

        case 10:
          _context10.next = 2;
          break;

        case 12:
        case "end":
          return _context10.stop();
      }
    }
  }, _marked9);
}
/**
 * Like izip2, but for three input iterables.
 */


function izip3(xs, ys, zs) {
  var ixs, iys, izs, x, y, z;
  return _regenerator["default"].wrap(function izip3$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          ixs = (0, _builtins.iter)(xs);
          iys = (0, _builtins.iter)(ys);
          izs = (0, _builtins.iter)(zs);

        case 3:
          x = ixs.next();
          y = iys.next();
          z = izs.next();

          if (!(!x.done && !y.done && !z.done)) {
            _context11.next = 11;
            break;
          }

          _context11.next = 9;
          return [x.value, y.value, z.value];

        case 9:
          _context11.next = 12;
          break;

        case 11:
          return _context11.abrupt("return");

        case 12:
          _context11.next = 3;
          break;

        case 14:
        case "end":
          return _context11.stop();
      }
    }
  }, _marked10);
}

var izip = izip2;
/**
 * Returns an iterator that aggregates elements from each of the iterables.  If
 * the iterables are of uneven length, missing values are filled-in with
 * fillvalue.  Iteration continues until the longest iterable is exhausted.
 */

exports.izip = izip;

function izipLongest2(xs, ys, filler) {
  var ixs, iys, x, y;
  return _regenerator["default"].wrap(function izipLongest2$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          ixs = (0, _builtins.iter)(xs);
          iys = (0, _builtins.iter)(ys);

        case 2:
          x = ixs.next();
          y = iys.next();

          if (!(x.done && y.done)) {
            _context12.next = 8;
            break;
          }

          return _context12.abrupt("return");

        case 8:
          _context12.next = 10;
          return [!x.done ? x.value : filler, !y.done ? y.value : filler];

        case 10:
          _context12.next = 2;
          break;

        case 12:
        case "end":
          return _context12.stop();
      }
    }
  }, _marked11);
}
/**
 * See izipLongest2, but for three.
 */


function izipLongest3(xs, ys, zs, filler) {
  var ixs, iys, izs, x, y, z;
  return _regenerator["default"].wrap(function izipLongest3$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          ixs = (0, _builtins.iter)(xs);
          iys = (0, _builtins.iter)(ys);
          izs = (0, _builtins.iter)(zs);

        case 3:
          x = ixs.next();
          y = iys.next();
          z = izs.next();

          if (!(x.done && y.done && z.done)) {
            _context13.next = 10;
            break;
          }

          return _context13.abrupt("return");

        case 10:
          _context13.next = 12;
          return [!x.done ? x.value : filler, !y.done ? y.value : filler, !z.done ? z.value : filler];

        case 12:
          _context13.next = 3;
          break;

        case 14:
        case "end":
          return _context13.stop();
      }
    }
  }, _marked12);
}
/**
 * Like the other izips (`izip`, `izip3`, etc), but generalized to take an
 * unlimited amount of input iterables.  Think `izip(*iterables)` in Python.
 *
 * **Note:** Due to Flow type system limitations, you can only "generially" zip
 * iterables with homogeneous types, so you cannot mix types like <A, B> like
 * you can with izip2().
 */


function izipMany() {
  var _len2,
      iters,
      _key2,
      iterables,
      heads,
      _args14 = arguments;

  return _regenerator["default"].wrap(function izipMany$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          for (_len2 = _args14.length, iters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            iters[_key2] = _args14[_key2];
          }

          // Make them all iterables
          iterables = iters.map(_builtins.iter);

        case 2:
          heads = iterables.map(function (xs) {
            return xs.next();
          });

          if (!(0, _builtins.all)(heads, function (h) {
            return !h.done;
          })) {
            _context14.next = 8;
            break;
          }

          _context14.next = 6;
          return heads.map(function (h) {
            return h.value;
          });

        case 6:
          _context14.next = 9;
          break;

        case 8:
          return _context14.abrupt("return");

        case 9:
          _context14.next = 2;
          break;

        case 11:
        case "end":
          return _context14.stop();
      }
    }
  }, _marked13);
}
/**
 * Return successive `r`-length permutations of elements in the iterable.
 *
 * If `r` is not specified, then `r` defaults to the length of the iterable and
 * all possible full-length permutations are generated.
 *
 * Permutations are emitted in lexicographic sort order.  So, if the input
 * iterable is sorted, the permutation tuples will be produced in sorted order.
 *
 * Elements are treated as unique based on their position, not on their value.
 * So if the input elements are unique, there will be no repeat values in each
 * permutation.
 */


function permutations(iterable, r) {
  var pool, n, x, indices, cycles, poolgetter, cleanExit, _iterator9, _step10, i, j, _ref2, p, q;

  return _regenerator["default"].wrap(function permutations$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          pool = Array.from(iterable);
          n = pool.length;
          x = r === undefined ? n : r;

          if (!(x > n)) {
            _context15.next = 5;
            break;
          }

          return _context15.abrupt("return");

        case 5:
          indices = Array.from((0, _builtins.range)(n));
          cycles = Array.from((0, _builtins.range)(n, n - x, -1));

          poolgetter = function poolgetter(i) {
            return pool[i];
          };

          _context15.next = 10;
          return indices.slice(0, x).map(poolgetter);

        case 10:
          if (!(n > 0)) {
            _context15.next = 45;
            break;
          }

          cleanExit = true;
          _iterator9 = _createForOfIteratorHelper((0, _builtins.range)(x - 1, -1, -1));
          _context15.prev = 13;

          _iterator9.s();

        case 15:
          if ((_step10 = _iterator9.n()).done) {
            _context15.next = 33;
            break;
          }

          i = _step10.value;
          cycles[i] -= 1;

          if (!(cycles[i] === 0)) {
            _context15.next = 23;
            break;
          }

          indices = indices.slice(0, i).concat(indices.slice(i + 1)).concat(indices.slice(i, i + 1));
          cycles[i] = n - i;
          _context15.next = 31;
          break;

        case 23:
          j = cycles[i];
          _ref2 = [indices[indices.length - j], indices[i]], p = _ref2[0], q = _ref2[1];
          indices[i] = p;
          indices[indices.length - j] = q;
          _context15.next = 29;
          return indices.slice(0, x).map(poolgetter);

        case 29:
          cleanExit = false;
          return _context15.abrupt("break", 33);

        case 31:
          _context15.next = 15;
          break;

        case 33:
          _context15.next = 38;
          break;

        case 35:
          _context15.prev = 35;
          _context15.t0 = _context15["catch"](13);

          _iterator9.e(_context15.t0);

        case 38:
          _context15.prev = 38;

          _iterator9.f();

          return _context15.finish(38);

        case 41:
          if (!cleanExit) {
            _context15.next = 43;
            break;
          }

          return _context15.abrupt("return");

        case 43:
          _context15.next = 10;
          break;

        case 45:
        case "end":
          return _context15.stop();
      }
    }
  }, _marked14, null, [[13, 35, 38, 41]]);
}
/**
 * Returns an iterator that produces values over and over again.  Runs
 * indefinitely unless the times argument is specified.
 */


function repeat(thing, times) {
  var _iterator10, _step11, i;

  return _regenerator["default"].wrap(function repeat$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          if (!(times === undefined)) {
            _context16.next = 7;
            break;
          }

        case 1:
          _context16.next = 3;
          return thing;

        case 3:
          _context16.next = 1;
          break;

        case 5:
          _context16.next = 24;
          break;

        case 7:
          // eslint-disable-next-line no-unused-vars
          _iterator10 = _createForOfIteratorHelper((0, _builtins.range)(times));
          _context16.prev = 8;

          _iterator10.s();

        case 10:
          if ((_step11 = _iterator10.n()).done) {
            _context16.next = 16;
            break;
          }

          i = _step11.value;
          _context16.next = 14;
          return thing;

        case 14:
          _context16.next = 10;
          break;

        case 16:
          _context16.next = 21;
          break;

        case 18:
          _context16.prev = 18;
          _context16.t0 = _context16["catch"](8);

          _iterator10.e(_context16.t0);

        case 21:
          _context16.prev = 21;

          _iterator10.f();

          return _context16.finish(21);

        case 24:
        case "end":
          return _context16.stop();
      }
    }
  }, _marked15, null, [[8, 18, 21, 24]]);
}
/**
 * Returns an iterator that produces elements from the iterable as long as the
 * predicate is true.
 */


function takewhile(iterable, predicate) {
  var _iterator11, _step12, value;

  return _regenerator["default"].wrap(function takewhile$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          _iterator11 = _createForOfIteratorHelper(iterable);
          _context17.prev = 1;

          _iterator11.s();

        case 3:
          if ((_step12 = _iterator11.n()).done) {
            _context17.next = 11;
            break;
          }

          value = _step12.value;

          if (predicate(value)) {
            _context17.next = 7;
            break;
          }

          return _context17.abrupt("return");

        case 7:
          _context17.next = 9;
          return value;

        case 9:
          _context17.next = 3;
          break;

        case 11:
          _context17.next = 16;
          break;

        case 13:
          _context17.prev = 13;
          _context17.t0 = _context17["catch"](1);

          _iterator11.e(_context17.t0);

        case 16:
          _context17.prev = 16;

          _iterator11.f();

          return _context17.finish(16);

        case 19:
        case "end":
          return _context17.stop();
      }
    }
  }, _marked16, null, [[1, 13, 16, 19]]);
}

function zipLongest2(xs, ys, filler) {
  return Array.from(izipLongest2(xs, ys, filler));
}

function zipLongest3(xs, ys, zs, filler) {
  return Array.from(izipLongest3(xs, ys, zs, filler));
}

var izipLongest = izipLongest2;
exports.izipLongest = izipLongest;
var zipLongest = zipLongest2;
exports.zipLongest = zipLongest;

function zipMany() {
  return Array.from(izipMany.apply(void 0, arguments));
}