function keepOnlyWorkableVulns(vuln) {
    return vuln.severity !== undefined || vuln.package !== undefined;
}
function extractDependenciesVulns(dependencies) {
    return Object.entries(dependencies)
        .flatMap(([_packageName, packageData]) => packageData.vulnerabilities)
        .filter(keepOnlyWorkableVulns);
}
function extractDependenciesWarnings(dependencies) {
    return Object.entries(dependencies).map(([packageName, packageData]) => {
        return {
            package: packageName,
            warnings: Object.values(packageData.versions).flatMap((packageVersionData) => packageVersionData.warnings)
        };
    });
}
function extractDependenciesVulnsAndWarnings(dependencies) {
    const warnings = extractDependenciesWarnings(dependencies);
    const vulnerabilities = extractDependenciesVulns(dependencies);
    return { warnings, vulnerabilities };
}
/**
 * In order to simplify the next step of scanner payload interpretation, we
 * extract reduce the payload data to only match interpreter requirements.
 */
export function extractScannerPayload(payload) {
    const { warnings, vulnerabilities } = extractDependenciesVulnsAndWarnings(payload.dependencies);
    return {
        warnings: payload.warnings,
        dependencies: {
            warnings,
            vulnerabilities
        }
    };
}
//# sourceMappingURL=extract.js.map