"use strict";

var _regeneratorRuntime2 = require("@babel/runtime/regenerator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;
exports.any = any;
exports.contains = contains;
exports.enumerate = enumerate;
exports.filter = filter;
exports.iter = iter;
exports.map = map;
exports.max = max;
exports.min = min;
exports.range = range;
exports.reduce = reduce;
exports.reduce_ = reduce_;
exports.sorted = sorted;
exports.sum = sum;
exports.zip = zip;
exports.zip3 = zip3;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _custom = require("./custom");

var _itertools = require("./itertools");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _marked = /*#__PURE__*/_regeneratorRuntime2.mark(enumerate);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Returns true when all of the items in iterable are truthy.  An optional key
 * function can be used to define what truthiness means for this specific
 * collection.
 *
 * Examples:
 *
 *     all([])                           // => true
 *     all([0])                          // => false
 *     all([0, 1, 2])                    // => false
 *     all([1, 2, 3])                    // => true
 *
 * Examples with using a key function:
 *
 *     all([2, 4, 6], n => n % 2 === 0)  // => true
 *     all([2, 4, 5], n => n % 2 === 0)  // => false
 *
 */
function all(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.identityPredicate;

  var _iterator = _createForOfIteratorHelper(iterable),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;

      if (!keyFn(item)) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return true;
}
/**
 * Returns true when any of the items in iterable are truthy.  An optional key
 * function can be used to define what truthiness means for this specific
 * collection.
 *
 * Examples:
 *
 *     any([])                           // => false
 *     any([0])                          // => false
 *     any([0, 1, null, undefined])      // => true
 *
 * Examples with using a key function:
 *
 *     any([1, 4, 5], n => n % 2 === 0)  // => true
 *     any([{name: 'Bob'}, {name: 'Alice'}], person => person.name.startsWith('C'))  // => false
 *
 */


function any(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.identityPredicate;

  var _iterator2 = _createForOfIteratorHelper(iterable),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var item = _step2.value;

      if (keyFn(item)) {
        return true;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return false;
}
/**
 * Returns true when any of the items in the iterable are equal to the target object.
 *
 * Examples:
 *
 *     contains([], 'whatever')         // => false
 *     contains([3], 42)                // => false
 *     contains([3], 3)                 // => true
 *     contains([0, 1, 2], 2)           // => true
 *
 */


function contains(haystack, needle) {
  return any(haystack, function (x) {
    return x === needle;
  });
}
/**
 * Returns an iterable of enumeration pairs.  Iterable must be a sequence, an
 * iterator, or some other object which supports iteration.  The elements
 * produced by returns a tuple containing a counter value (starting from 0 by
 * default) and the values obtained from iterating over given iterable.
 *
 * Example:
 *
 *     import { enumerate } from 'itertools';
 *
 *     console.log([...enumerate(['hello', 'world'])]);
 *     // [0, 'hello'], [1, 'world']]
 */


function enumerate(iterable) {
  var start,
      index,
      _iterator3,
      _step3,
      value,
      _args = arguments;

  return _regenerator["default"].wrap(function enumerate$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          start = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
          index = start;
          _iterator3 = _createForOfIteratorHelper(iterable);
          _context.prev = 3;

          _iterator3.s();

        case 5:
          if ((_step3 = _iterator3.n()).done) {
            _context.next = 11;
            break;
          }

          value = _step3.value;
          _context.next = 9;
          return [index++, value];

        case 9:
          _context.next = 5;
          break;

        case 11:
          _context.next = 16;
          break;

        case 13:
          _context.prev = 13;
          _context.t0 = _context["catch"](3);

          _iterator3.e(_context.t0);

        case 16:
          _context.prev = 16;

          _iterator3.f();

          return _context.finish(16);

        case 19:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[3, 13, 16, 19]]);
}
/**
 * Non-lazy version of ifilter().
 */


function filter(iterable, predicate) {
  return Array.from((0, _itertools.ifilter)(iterable, predicate));
}
/**
 * Returns an iterator object for the given iterable.  This can be used to
 * manually get an iterator for any iterable datastructure.  The purpose and
 * main use case of this function is to get a single iterator (a thing with
 * state, think of it as a "cursor") which can only be consumed once.
 */


function iter(iterable) {
  // TODO: Not sure why Flow choked on this expression below, but at least we lock down the
  // type transformation in the function signature this way.
  // $FlowFixMe[incompatible-use]
  return iterable[Symbol.iterator]();
}
/**
 * Non-lazy version of imap().
 */


function map(iterable, mapper) {
  return Array.from((0, _itertools.imap)(iterable, mapper));
}
/**
 * Return the largest item in an iterable.  Only works for numbers, as ordering
 * is pretty poorly defined on any other data type in JS.  The optional `keyFn`
 * argument specifies a one-argument ordering function like that used for
 * sorted().
 *
 * If the iterable is empty, `undefined` is returned.
 *
 * If multiple items are maximal, the function returns either one of them, but
 * which one is not defined.
 */


function max(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.numberIdentity;
  return reduce_(iterable, function (x, y) {
    return keyFn(x) > keyFn(y) ? x : y;
  });
}
/**
 * Return the smallest item in an iterable.  Only works for numbers, as
 * ordering is pretty poorly defined on any other data type in JS.  The
 * optional `keyFn` argument specifies a one-argument ordering function like
 * that used for sorted().
 *
 * If the iterable is empty, `undefined` is returned.
 *
 * If multiple items are minimal, the function returns either one of them, but
 * which one is not defined.
 */


function min(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.numberIdentity;
  return reduce_(iterable, function (x, y) {
    return keyFn(x) < keyFn(y) ? x : y;
  });
}
/**
 * Internal helper for the range function
 */


function _range(start, stop, step) {
  var counter = (0, _itertools.count)(start, step);
  var pred = step >= 0 ? function (n) {
    return n < stop;
  } : function (n) {
    return n > stop;
  };
  return (0, _itertools.takewhile)(counter, pred);
}
/**
 * Returns an iterator producing all the numbers in the given range one by one,
 * starting from `start` (default 0), as long as `i < stop`, in increments of
 * `step` (default 1).
 *
 * `range(a)` is a convenient shorthand for `range(0, a)`.
 *
 * Various valid invocations:
 *
 *     range(5)           // [0, 1, 2, 3, 4]
 *     range(2, 5)        // [2, 3, 4]
 *     range(0, 5, 2)     // [0, 2, 4]
 *     range(5, 0, -1)    // [5, 4, 3, 2, 1]
 *     range(-3)          // []
 *
 * For a positive `step`, the iterator will keep producing values `n` as long
 * as the stop condition `n < stop` is satisfied.
 *
 * For a negative `step`, the iterator will keep producing values `n` as long
 * as the stop condition `n > stop` is satisfied.
 *
 * The produced range will be empty if the first value to produce already does
 * not meet the value constraint.
 */


function range(a) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var args = [a].concat(rest); // "a" was only used by Flow to make at least one value mandatory

  switch (args.length) {
    case 1:
      return _range(0, args[0], 1);

    case 2:
      return _range(args[0], args[1], 1);

    case 3:
      return _range(args[0], args[1], args[2]);

    /* istanbul ignore next */

    default:
      throw new Error('invalid number of arguments');
  }
}
/**
 * Apply function of two arguments cumulatively to the items of sequence, from
 * left to right, so as to reduce the sequence to a single value.  For example:
 *
 *     reduce([1, 2, 3, 4, 5], (x, y) => x + y, 0)
 *
 * calculates
 *
 *     (((((0+1)+2)+3)+4)+5)
 *
 * The left argument, `x`, is the accumulated value and the right argument,
 * `y`, is the update value from the sequence.
 *
 * **Difference between `reduce()` and `reduce\_()`**:  `reduce()` requires an
 * explicit initializer, whereas `reduce_()` will automatically use the first
 * item in the given iterable as the initializer.  When using `reduce()`, the
 * initializer value is placed before the items of the sequence in the
 * calculation, and serves as a default when the sequence is empty.  When using
 * `reduce_()`, and the given iterable is empty, then no default value can be
 * derived and `undefined` will be returned.
 */


function reduce(iterable, reducer, start) {
  var it = iter(iterable);
  var output = start;

  var _iterator4 = _createForOfIteratorHelper(enumerate(it)),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 2),
          index = _step4$value[0],
          item = _step4$value[1];

      output = reducer(output, item, index);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return output;
}
/**
 * See reduce().
 */


function reduce_(iterable, reducer) {
  var it = iter(iterable);
  var start = (0, _custom.first)(it);

  if (start === undefined) {
    return undefined;
  } else {
    return reduce(it, reducer, start);
  }
}
/**
 * Return a new sorted list from the items in iterable.
 *
 * Has two optional arguments:
 *
 * * `keyFn` specifies a function of one argument providing a primitive
 *   identity for each element in the iterable.  that will be used to compare.
 *   The default value is to use a default identity function that is only
 *   defined for primitive types.
 *
 * * `reverse` is a boolean value.  If `true`, then the list elements are
 *   sorted as if each comparison were reversed.
 */


function sorted(iterable) {
  var keyFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _utils.primitiveIdentity;
  var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var result = Array.from(iterable);
  result.sort((0, _utils.keyToCmp)(keyFn)); // sort in-place

  if (reverse) {
    result.reverse(); // reverse in-place
  }

  return result;
}
/**
 * Sums the items of an iterable from left to right and returns the total.  The
 * sum will defaults to 0 if the iterable is empty.
 */


function sum(iterable) {
  return reduce(iterable, function (x, y) {
    return x + y;
  }, 0);
}
/**
 * See izip.
 */


function zip(xs, ys) {
  return Array.from((0, _itertools.izip)(xs, ys));
}
/**
 * See izip3.
 */


function zip3(xs, ys, zs) {
  return Array.from((0, _itertools.izip3)(xs, ys, zs));
}